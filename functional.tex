% -*- coding: utf-8 -*-
% !TEX program = lualatex
\documentclass[oneside]{book}
\usepackage[a4paper,margin=2.5cm]{geometry}

\newcommand*{\myversion}{2022A}
\newcommand*{\mydate}{Version \myversion\ (\the\year-\mylpad\month-\mylpad\day)}
\newcommand*{\mylpad}[1]{\ifnum#1<10 0\the#1\else\the#1\fi}

\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 1pt minus 1pt}

\usepackage{codehigh}

\colorlet{highback}{blue9}
%\CodeHigh{lite}
\CodeHigh{language=latex/latex2,style/main=highback,style/code=highback}
\NewCodeHighEnv{code}{style/main=gray9,style/code=gray9}
\NewCodeHighEnv{demo}{style/main=gray9,style/code=gray9,demo}

\NewDocumentCommand\MySubScript{m}{$_{#1}$}

\ExplSyntaxOn
\NewDocumentCommand\PrintVarList{m}{
  \clist_set:Nn \l_tmpa_clist {#1}
  \clist_map_inline:Nn \l_tmpa_clist
    {
      \token_to_str:N ##1 ~
    }
}
\NewDocumentCommand\RelaceChacters{m}{
  \tl_set:Nn \lTmpaTl {#1}
  \regex_replace_once:nnN { \_ } { \c{MySubScript} } \lTmpaTl
}
\ExplSyntaxOff

\NewDocumentEnvironment{variable}{om}{
  \vspace{5pt}
  \begin{minipage}{\linewidth}
  \hrule\vspace{4pt}\obeylines%
  \begingroup
  \ttfamily\bfseries\color{azure3}
  \PrintVarList{#2}
  \endgroup
  \par\vspace{4pt}\hrule
  \end{minipage}\par\nopagebreak\vspace{4pt}
}{%
  \vspace{5pt}%
}

\NewDocumentEnvironment{function}{om}{
  \vspace{5pt}%
}{\vspace{5pt}}

\NewDocumentEnvironment{syntax}{}{%
  \begin{minipage}{\linewidth}
  \hrule\vspace{4pt}\obeylines%
}{%
  \par\vspace{4pt}\hrule
  \end{minipage}\par\nopagebreak\vspace{4pt}
}

\NewDocumentEnvironment{texnote}{}{}{}

\NewDocumentCommand\cs{m}{%
  \texttt{\bfseries\color{purple3}\expandafter\string\csname#1\endcsname}%
}
\NewDocumentCommand\meta{m}{%
  \RelaceChacters{#1}%
  \textsl{$\langle$\ignorespaces\lTmpaTl\unskip$\rangle$}%
}
\NewDocumentCommand\Arg{m}{%
  \RelaceChacters{#1}%
  \texttt{\{}\textsl{$\langle$\ignorespaces\lTmpaTl\unskip$\rangle$}\texttt{\}}%
}

\NewDocumentCommand\nan{}{\texttt{NaN}}
\NewDocumentCommand\enquote{m}{``#1''}

\let\tn=\cs

\RenewDocumentCommand\emph{m}{%
  \underline{\textsl{#1}}%
}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  urlcolor=blue3,
  linkcolor=blue3,
}

\usepackage{functional}
%\Functional{scoping=false,tracing=true}

\begin{document}

\title{\sffamily LaTeX2 \textcolor{green3}{Functional} Interfaces to LaTeX3 Programming Layer}
\author{Jianrui Lyu (tolvjr@163.com)\\\url{https://github.com/lvjr/functional}}
\date{\mydate\vspace{1cm}\\\myabstract\vspace{10cm}}

\newcommand\myabstract{\parbox{\linewidth}{\hrule\vspace{0.8em}\large
LaTeX3 programming layer (\textsf{expl3}) is very powerful for advanced users,
but it is a little complicated for normal users.
This \textcolor{green3}{\sffamily functional} package aims to provide
intuitive LaTeX2 functional interfaces for it.
\par\vspace{0.5em}
Although there are functions in LaTeX3, the evaluation of them is from outside to inside.
With this package, the evaluation of functions is from inside to outside,
which is the same as other programming languages such as \texttt{JavaScript} or \texttt{Lua}.
In this way, it is rather easy to debug code too.
\par\vspace{0.5em}
Note that many paragraphs in this manual are copied from the documentation of \textsf{expl3}.
\par\vspace{0.8em}\hrule}}

{\let\newpage\relax\vspace{-4cm}\maketitle}

\tableofcontents

\chapter{Overview of Features}

\section{Evaluation from Inside to Outside}

We will compare our first example with a similar \verb!Lua! example:

\begin{code}
-- lua code --
function MathSquare (arg)
  local lTmpaInt = arg * arg
  return lTmpaInt
end
print(MathSquare(5))
print(MathSquare(MathSquare(5)))
\end{code}

\begin{codehigh}
%% function code
\IgnoreSpacesOn
\PrgNewFunction \MathSquare { m } {
  \IntSet \lTmpaInt { \IntEval { #1 * #1 } }
  \Result { \Value \lTmpaInt }
}
\IgnoreSpacesOff
\MathSquare{5}
\MathSquare{\MathSquare{5}}
\end{codehigh}

%\IgnoreSpacesOn
%\PrgNewFunction \MathSquare { m }{
%  \IntSet \lTmpaInt { \IntEval { #1 * #1 } }
%  \Result { \Value \lTmpaInt }
%}
%\IgnoreSpacesOff
%\MathSquare{5}
%\MathSquare{\MathSquare{5}}

%\IgnoreSpacesOn
%\PrgNewFunction \MathCubic { m }
%  {
%    \IntSet \lTmpaInt { \IntEval { #1 * #1 * #1 } }
%    \Result { \Value \lTmpaInt }
%  }
%\IgnoreSpacesOff
%\MathCubic{2}
%\MathCubic{\MathCubic{2}}

Both examples calculate first the square of $5$ and produce $25$,
then calculate the square of $25$ and produce $625$.
In contrast to \verb!expl3!, this \verb!functional! package
does evaluation of functions from inside to outside,
which means composition of functions works like othe programming languages
such as \verb!Lua! or \verb!JavsScript!.

You can define new functions with \cs{PrgNewFunction} command.
To make composition of functions work as expected,
every function \emph{must not} insert directly any token to the input stream.
Instead, a function \emph{must} pass the result (if any) to \verb!functional! package
with \cs{Result} command. And \verb!functional! package is responsible for
inserting result tokens to the input stream at the appropriate time.

To remove space tokens inside function code in defining functions,
you'd better put function definitions inside \verb!\IgnoreSpacesOn! and
\verb!\IgnoreSpacesOff! block. Within this block, \verb!~! is used to input a space.

At the end of this section,
we will compare our factorial example with a similar \verb!Lua! example:

\begin{code}
-- lua code --
function Factorial (n)
  if n == 0 then
    return 1
  else
    return n * Factorial(n-1)
  end
end
print(Factorial(4))
\end{code}

\begin{codehigh}
\IgnoreSpacesOn
\PrgNewFunction \Factorial { m } {
  \IntCompareTF {#1} = {0} {
    \Result {1}
  }{
    \Result { \IntMathMult {#1} { \Factorial { \IntMathSub{#1}{1} } } }
  }
}
\IgnoreSpacesOff
\Factorial{4}
\end{codehigh}

%\IgnoreSpacesOn
%\PrgNewFunction \Factorial { m } {
%  \IntCompareTF {#1} = {0} {
%    \Result {1}
%  }{
%    \Result { \IntMathMult {#1} { \Factorial { \IntMathSub{#1}{1} } } }
%  }
%}
%\IgnoreSpacesOff
%\Factorial{0}
%\Factorial{4}

\section{Group Scoping of Functions}

In \verb!Lua! language, a function or a condition expression makes a block,
and the values of local variables will be reset after a block.
For example

\begin{code}
-- lua code --
local a = 1
print(a)          ---- 1
function SomeFun()
  local a = 2
  print(a)        ---- 2
  if 1 > 0 then
    local a = 3
    print(a)      ---- 3
  end
  print(a)        ---- 2
end
SomeFun()
print(a)          ---- 1
\end{code}

In \verb!functional! package, a condition expression is in fact a function,
and you can make every function become a group by setting
\verb!\Functional{scoping=true}!. For example

\begin{codehigh}
\Functional{scoping=true}
\IgnoreSpacesOn
\IntSet \lTmpaInt {1}
\IntLogVar \lTmpaInt          % ---- 1
\PrgNewFunction \SomeFun { } {
  \IntSet \lTmpaInt {2}
  \IntLogVar \lTmpaInt        % ---- 2
  \IntCompareTF {1} > {0} {
    \IntSet \lTmpaInt {3}
    \IntLogVar \lTmpaInt      % ---- 3
  }{ }
  \IntLogVar \lTmpaInt        % ---- 2
}
\SomeFun
\IntLogVar \lTmpaInt          % ---- 1
\IgnoreSpacesOff
\end{codehigh}

Same as \verb!expl3!, the names of local variables \emph{must} start with \verb!l!,
while names of global variables \emph{must} start with \verb!g!.
The difference is that \verb!functional! package provides only one function for setting
both local and global varianbles of the same type,
by checking leading letters of their names. So for integer variables, you can write
\verb!\IntSet\lTmpaInt{1}! and \verb!\IntSet\gTmpbInt{2}!.

The previous example will produce different result
if we change variable from \verb!\lTmpaInt! to \verb!\gTmpaInt!.

\begin{codehigh}
\Functional{scoping=true}
\IgnoreSpacesOn
\IntSet \gTmpaInt {1}
\IntLogVar \gTmpaInt          % ---- 1
\PrgNewFunction \SomeFun { } {
  \IntSet \gTmpaInt {2}
  \IntLogVar \gTmpaInt        % ---- 2
  \IntCompareTF {1} > {0} {
    \IntSet \gTmpaInt {3}
    \IntLogVar \gTmpaInt      % ---- 3
  }{ }
  \IntLogVar \gTmpaInt        % ---- 3
}
\SomeFun
\IntLogVar \gTmpaInt          % ---- 3
\IgnoreSpacesOff
\end{codehigh}

As you can see, the values of global variables will never be reset after a group.

\section{Tracing Evaluation of Functions}

Since every function in \verb!functional! package will pass its return value to
the package, it is quite easy to debug your code.
You can turn on the tracing by setting \verb!\Functional{tracing=true}!.
For example, the tracing log of the first example in this chapter will be the following:

% FIXME: spaces at the first line will be removed
%\begin{codehigh}[]
%    [I] \MathSquare{5}
%            [I] \IntEval{5*5}
%                    [I] \Expand{\int_eval:n {5*5}}
%                    [O] 25
%                [I] \Result{25}
%                [O] 25
%            [O] 25
%        [I] \IntSet\lTmpaInt {25}
%        [O]
%            [I] \Value\lTmpaInt
%            [O] 25
%        [I] \Result{25}
%        [O] 25
%    [O] 25
%\end{codehigh}
\begin{codehigh}[]
[I] \MathSquare{5}
        [I] \IntEval{5*5}
                [I] \Expand{\int_eval:n {5*5}}
                [O] 25
            [I] \Result{25}
            [O] 25
        [O] 25
    [I] \IntSet\lTmpaInt {25}
    [O]
        [I] \Value\lTmpaInt
        [O] 25
    [I] \Result{25}
    [O] 25
[O] 25
[I] \MathSquare{25}
        [I] \IntEval{25*25}
                [I] \Expand{\int_eval:n {25*25}}
                [O] 625
            [I] \Result{625}
            [O] 625
        [O] 625
    [I] \IntSet\lTmpaInt {625}
    [O]
        [I] \Value\lTmpaInt
        [O] 625
    [I] \Result{625}
    [O] 625
[O] 625
\end{codehigh}

\section{Definitions of Functions}

Within \verb!expl3!, there are eight commands for defining new functions,
which is good for power users.

\begin{code}[language=latex/latex3]
\cs_new:Npn
\cs_new_nopar:Npn
\cs_new_protected:Npn
\cs_new_protected_nopar:Npn
\cs_new:Nn
\cs_new_nopar:Nn
\cs_new_protected:Nn
\cs_new_protected_nopar:Nn
\end{code}

Within \verb!functional! package, there is only one command (\cs{PrgNewFunction})
for defining new functions, which is good for normal users.
The created functions are always protected and accept \verb!\par! in their arguments.

Since \verb!functional! package gets the results of functions by evaluation
(including expansion and execution by \TeX), it is natural to protect all functions.

\section{Variants of Arguments}

Within \verb!expl3!, there are several expansion variants for arguments,
and many expansion functions for expanding them, which are necessary for power users.

\begin{code}[language=latex/latex3]
\module_foo:c
\module_bar:e
\module_bar:x
\module_bar:f
\module_bar:o
\module_bar:V
\module_bar:v
\end{code}

\begin{code}[language=latex/latex3]
\exp_args:Nc
\exp_args:Ne
\exp_args:Nx
\exp_args:Nf
\exp_args:No
\exp_args:NV
\exp_args:Nv
\end{code}

Within \verb!functional! package, there are only three variants
(\verb!c!, \verb!e!, \verb!V!) are provided, and these variants are defined
as functions (\cs{Name}, \cs{Expand}, \cs{Value}, respetively),
which are easier to use for normal users.

\begin{demohigh}
\newcommand\test{uvw}
\Name{test}
\end{demohigh}

\begin{demohigh}
\newcommand\test{uvw}
\Expand{111\test222}
\end{demohigh}

\begin{demohigh}
\IntSet\lTmpaInt{123}
\Value\lTmpaInt
\end{demohigh}

The most interesting feature is that you can compose these functions.
For example, you can easily get the \verb!v! variant of \verb!expl3! by
simply composing \cs{Name} and \cs{Value} functions:

\begin{demohigh}
\IntSet\lTmpaInt{123}
\Value{\Name{lTmpaInt}}
\end{demohigh}

\chapter{Functional Progarmming (\texttt{Prg})}

\section{Deï¬ning Functions and Conditionals}

\begin{function}{\PrgNewFunction}
\begin{syntax}
\cs{PrgNewFunction} \meta{function} \Arg{argument specification} \Arg{code}
\end{syntax}
Creates protected \meta{function} for evaluating the \meta{code}.
Within the \meta{code}, the parameters (\verb|#1|, \verb|#2|,
\emph{etc.}) will be replaced by those absorbed by the function.
The returned value \emph{must} be passed with \cs{Result} function.
The definition is global and an error results if the
\meta{function} is already defined.\par
The \Arg{argument specification} in a list of letters,
where each letter is one of the following argument specifiers
(nearly all of them are \texttt{M} or \texttt{m} for functions provided by this package):\par
{\centering\begin{tabular}{ll}
%\hline
  \texttt{M} & single-token argument, which will be manipulated first \\
  \texttt{m} & multi-token argument, which will be manipulated first \\
  \texttt{N} & single-token argument, which will not be manipulated first \\
  \texttt{n} & multi-token argument, which will not be manipulated first \\
%\hline
\end{tabular}\par}
The argument manipulation for argument type \texttt{M} or \texttt{m}
is: if the argument starts with a function defined with \cs{PrgNewFunction},
the argument will be evaluated and replaced with the returned value.
\end{function}

\begin{function}{\PrgNewConditional}
\begin{syntax}
\cs{PrgNewConditional} \meta{function} \Arg{argument specification} \Arg{code}
\end{syntax}
Creates protected conditional \meta{function} for evaluating the \meta{code}.
The returned value of the \meta{function} \emph{must} be either \verb!\cTrueBool!
or \verb!\cFalseBool! and be passed with \cs{Result} function..
The definition is global and an error results if the \meta{function} is already defined.
\par
Assume the \meta{function} is \verb!\FooIfBar!, then another function \verb!\FooIfBarTF!
will be created at the same time. \verb!\FooIfBarTF! function has two extra arguments
which are \Arg{true code} and \Arg{false code}.\par
\end{function}

\section{Collecting Returned Values}

\begin{function}{\Result}
\begin{syntax}
\cs{Result} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to \verb!\gResultTl!, which holds the returned value of current function.
This function is normally used in the \meta{code} of \cs{PrgNewFunction} and \cs{PrgNewConditional}.
\end{function}

\chapter{Argument Using (\texttt{Use})}

\section{Expanding Tokens}

\begin{function}{\Name}
\begin{syntax}
\cs{Name} \Arg{control sequence name}
\end{syntax}
Expands the \meta{control sequence name} until only characters
remain, then converts this into a control sequence and returns it.
The \meta{control sequence name} must consist of character tokens %,
%typically a mixture of category code $10$ (space), $11$ (letter) and $12$ (other).
when exhaustively expanded.%
%\begin{texnote}
%Protected macros that appear in a \texttt{c}-type argument are
%expanded despite being protected; \cs{exp_not:n} also has no
%effect.  An internal error occurs if non-characters or active
%characters remain after full expansion, as the conversion to a
%control sequence is not possible.
%\end{texnote}
\end{function}

\begin{function}{\Value}
\begin{syntax}
\cs{Value} \meta{variable}
\end{syntax}
Recovers the content of a \meta{variable} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
Note that it is the same as \cs{TlUse} for \meta{tl var}, or \cs{IntUse} for \meta{int var}.
\end{function}

\begin{function}{\Expand}
\begin{syntax}
\cs{Expand} \Arg{tokens}
\end{syntax}
Expands the \meta{tokens} exhaustively and returns the result.
\end{function}

\begin{function}{\ExpNot}
\begin{syntax}
\cs{ExpNot} \Arg{tokens}
\end{syntax}
Prevents expansion of the \meta{tokens} inside the argument of \cs{Expand} function.
The argument of \cs{ExpNot} \emph{must} be surrounded by braces.
%\begin{texnote}
%This is the \eTeX{} \tn{unexpanded} primitive.  In an
%|x|-expanding definition (\cs{cs_new:Npx}), \cs{exp_not:n}~|{#1}|
%is equivalent to |##1| rather than to~|#1|, namely it inserts the
%two characters |#| and~|1|.  In an |e|-type argument
%\cs{exp_not:n}~|{#}| is equivalent to |#|, namely it inserts the
%character~|#|.
%\end{texnote}
\end{function}

\begin{function}{\ExpValue}
\begin{syntax}
\cs{ExpValue} \meta{variable}
\end{syntax}
Recovers the content of the \meta{variable}, then prevents expansion
of this material inside the argument of \cs{Expand} function.
\end{function}

\section{Using Tokens}

\begin{function}{\UseOne,\GobbleOne}
\begin{syntax}
\cs{UseOne} \Arg{argument}
\cs{GobbleOne} \Arg{argument}
\end{syntax}
The function \cs{UseOne} absorbs one argument and returns it.
%\begin{texnote}
%The \cs{UseOne} function is equivalent to \LaTeXe{}'s \tn{@firstofone}.
%\end{texnote}
\cs{GobbleOne} absorbs one argument and returns nothing.
%\begin{texnote}
%These are equivalent to \LaTeXe{}'s \tn{@gobble}, \tn{@gobbbletwo},
%\emph{etc.}
%\end{texnote}
For example
\begin{demohigh}
\UseOne{abc}\GobbleOne{ijk}\UseOne{xyz}
\end{demohigh}
\end{function}

\begin{function}{\UseGobble,\GobbleUse}
\begin{syntax}
\cs{UseGobble} \Arg{arg_1} \Arg{arg_2}
\cs{GobbleUse} \Arg{arg_1} \Arg{arg_2}
\end{syntax}
These functions absorb two arguments.
The function \cs{UseGobble} discards the second argument,
and returns the content of the first argument.
\cs{GobbleUse} discards the first argument,
and returns the content of the second argument.
%\begin{texnote}
%These are equivalent to \LaTeXe{}'s \tn{@firstoftwo} and
%\tn{@secondoftwo}.
%\end{texnote}
For example
\begin{demohigh}
\UseGobble{abc}{uvw}\GobbleUse{abc}{uvw}
\end{demohigh}
\end{function}

\chapter{Control Structures (\texttt{Bool})}

\section{Scratch Variables of Booleans}

\begin{variable}{\lTmpaBool,\lTmpbBool,\lTmpcBool,\lTmpiBool,\lTmpjBool,\lTmpkBool}
Scratch booleans for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaBool,\gTmpbBool,\gTmpcBool,\gTmpiBool,\gTmpjBool,\gTmpkBool}
Scratch booleans for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

%\BoolIfTF\cTrueBool{\Result{true}}{\Result{false}}
%\BoolIfTF\cFalseBool{\Result{true}}{\Result{false}}

\section{Public Functions for Booleans}

\begin{function}{\BoolNew}
\begin{syntax}
\cs{BoolNew} \meta{boolean}
\end{syntax}
Creates a new \meta{boolean} or raises an error if the
name is already taken. The declaration is global. The
\meta{boolean} is initially \texttt{false}.
\end{function}

\begin{function}{\BoolSetTrue}
\begin{syntax}
\cs{BoolSetTrue} \meta{boolean}
\end{syntax}
Sets \meta{boolean} logically \texttt{true}.
\end{function}

\begin{function}{\BoolSetFalse}
\begin{syntax}
\cs{BoolSetFalse} \meta{boolean}
\end{syntax}
Sets \meta{boolean} logically \texttt{false}.
\end{function}

\begin{function}{\BoolIf,\BoolIfTF}
\begin{syntax}
\cs{BoolIf} \meta{boolean}
\cs{BoolIfTF} \meta{boolean} \Arg{true code} \Arg{false code}
\end{syntax}
Tests the current truth of \meta{boolean}, and continues evaluation
based on this result. For example
\begin{demohigh}
\BoolSetTrue\lTmpaBool
\BoolIfTF\lTmpaBool{\Result{True!}}{\Result{False!}}
\BoolSetFalse\lTmpaBool
\BoolIfTF\lTmpaBool{\Result{True!}}{\Result{False!}}
\end{demohigh}
\end{function}

\chapter{Token Lists (\texttt{Tl})}

\section{Scratch Variables of Token Lists}

\begin{variable}{\lTmpaTl,\lTmpbTl,\lTmpcTl,\lTmpiTl,\lTmpjTl,\lTmpkTl}
Scratch token lists for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaTl,\gTmpbTl,\gTmpcTl,\gTmpiTl,\gTmpjTl,\gTmpkTl}
Scratch token lists for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Token Lists}

\begin{function}{\TlNew}
\begin{syntax}
\cs{TlNew} \meta{tl~var}
\end{syntax}
Creates a new \meta{tl~var} or raises an error if the
name is already taken. The declaration is global. The
\meta{tl~var} is initially empty.
\end{function}

\begin{function}{\TlUse}
\begin{syntax}
\cs{TlUse} \meta{tl~var}
\end{syntax}
Recovers the content of a \meta{tl~var} and returns the value.
An error is raised if the variable
does not exist or if it is invalid. Note that it is possible to use
a \meta{tl~var} directly without an accessor function.
\end{function}

\begin{function}{\TlSet}
\begin{syntax}
\cs{TlSet} \meta{tl~var} \Arg{tokens}
\end{syntax}
Sets \meta{tl~var} to contain \meta{tokens},
removing any previous content from the variable. For example
\begin{demohigh}
\TlSet\lTmpiTl{\IntMathMult{4}{5}}
\TlUse\lTmpiTl
\end{demohigh}
\end{function}

\begin{function}{\TlClear}
\begin{syntax}
\cs{TlClear} \meta{tl~var}
\end{syntax}
Clears all entries from the \meta{tl~var}. For example
\begin{demohigh}
\TlSet\lTmpjTl{One}
\TlClear\lTmpjTl
\TlSet\lTmpjTl{Two}
\TlUse\lTmpjTl
\end{demohigh}
\end{function}

\begin{function}{\TlPutLeft}
\begin{syntax}
\cs{TlPutLeft} \meta{tl~var} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to the left side of the current content of
\meta{tl~var}. For example
\begin{demohigh}
\TlSet\lTmpkTl{Functional}
\TlPutLeft\lTmpkTl{Hello}
\TlUse\lTmpkTl
\end{demohigh}
\end{function}

\begin{function}{\TlPutRight}
\begin{syntax}
\cs{TlPutRight} \meta{tl~var} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to the right side of the current content of
\meta{tl~var}. For example
\begin{demohigh}
\TlSet\lTmpkTl{Functional}
\TlPutRight\lTmpkTl{World}
\TlUse\lTmpkTl
\end{demohigh}
\end{function}

\begin{function}{\TlIfVarEmpty,\TlIfVarEmptyTF}
\begin{syntax}
\cs{TlIfVarEmpty} \meta{tl~var}
\cs{TlIfVarEmptyTF} \meta{tl~var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list variable} is entirely empty
(\emph{i.e.}~contains no tokens at all). For example
\begin{demohigh}
\TlSet\lTmpaTl{abc}
\TlIfVarEmptyTF\lTmpaTl{\Result{Empty}}{\Result{NonEmpty}}
\TlClear\lTmpaTl
\TlIfVarEmptyTF\lTmpaTl{\Result{Empty}}{\Result{NonEmpty}}
\end{demohigh}
\end{function}

\begin{function}{\TlIfEq,\TlIfEqTF}
\begin{syntax}
\cs{TlIfEq} \Arg{token list_1} \Arg{token list_2}
\cs{TlIfEqTF} \Arg{token list_1} \Arg{token list_2} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if \meta{token list_1} and \meta{token list_2} contain the
same list of tokens, both in respect of character codes and category
codes. See \cs{StrIfEq} if category codes are not important.
For example
\begin{demohigh}
\TlIfEqTF{abc}{abc}{\Result{Yes}}{\Result{No}}
\TlIfEqTF{abc}{xyz}{\Result{Yes}}{\Result{No}}
\end{demohigh}
%\begin{demohigh}
%\TlSet\lTmpaTl{abc}
%\TlSet\lTmpbTl{abc}
%\TlSet\lTmpcTl{xyz}
%\TlIfEqTF{\TlUse\lTmpaTl}{\TlUse\lTmpbTl}{\Result{Yes}}{\Result{No}}
%\TlIfEqTF{\TlUse\lTmpaTl}{\TlUse\lTmpcTl}{\Result{Yes}}{\Result{No}}
%\end{demohigh}
\end{function}

\begin{function}{\TlIfVarEq,\TlIfVarEqTF}
\begin{syntax}
\cs{TlIfVarEq} \meta{tl var_1} \meta{tl var_2}
\cs{TlIfVarEqTF} \meta{tl var_1} \meta{tl var_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the content of two \meta{token list variables} and
is logically \texttt{true} if the two contain the same list of
tokens (\emph{i.e.}~identical in both the list of characters they
contain and the category codes of those characters). For example
\begin{demohigh}
\TlSet\lTmpaTl{abc}
\TlSet\lTmpbTl{abc}
\TlSet\lTmpcTl{xyz}
\TlIfVarEqTF\lTmpaTl\lTmpbTl{\Result{Yes}}{\Result{No}}
\TlIfVarEqTF\lTmpaTl\lTmpcTl{\Result{Yes}}{\Result{No}}
\end{demohigh}
See also \cs{StrIfVarEq} for a comparison that ignores category codes.
\end{function}

\chapter{Strings (\texttt{Str})}

\section{Scratch Variables of Strings}

\begin{variable}{\lTmpaStr,\lTmpbStr,\lTmpcStr,\lTmpiStr,\lTmpjStr,\lTmpkStr}
Scratch strings for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaStr,\gTmpbStr,\gTmpcStr,\gTmpiStr,\gTmpjStr,\gTmpkStr}
Scratch strings for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Strings}

\begin{function}{\StrNew}
\begin{syntax}
\cs{StrNew} \meta{str var}
\end{syntax}
Creates a new \meta{str var} or raises an error if the name is
already taken. The declaration is global. The \meta{str var} is
initially empty.
\end{function}

\begin{function}{\StrLogVar}
\begin{syntax}
\cs{StrLogVar} \meta{str var}
\end{syntax}
Writes the content of the \meta{str var} in the log file.
For example
\begin{codehigh}
\StrSet\lTmpiStr{1234\abcd5678}
\StrLogVar\lTmpiStr
\end{codehigh}
\end{function}

\begin{function}{\StrShowVar}
\begin{syntax}
\cs{StrShowVar} \meta{str var}
\end{syntax}
Displays the content of the \meta{str var} on the terminal.
\end{function}

\begin{function}{\StrUse}
\begin{syntax}
\cs{StrUse} \meta{str var}
\end{syntax}
Recovers the content of a \meta{str var} and returns the value.
An error is raised if the variable
does not exist or if it is invalid. Note that it is possible to use
a \meta{str} directly without an accessor function.
\end{function}

\begin{function}{\StrSet}
\begin{syntax}
\cs{StrSet} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and stores the
result in \meta{str var}. For example
\begin{demohigh}
\StrSet\lTmpiStr{\IntMathMult{4}{5}}
\StrUse\lTmpiStr
\end{demohigh}
\end{function}

\begin{function}{\StrClear}
\begin{syntax}
\cs{StrClear} \meta{str var}
\end{syntax}
Clears the content of the \meta{str var}. For example
\begin{demohigh}
\StrSet\lTmpjStr{One}
\StrClear\lTmpjStr
\StrSet\lTmpjStr{Two}
\StrUse\lTmpjStr
\end{demohigh}
\end{function}

\begin{function}{\StrPutLeft}
\begin{syntax}
\cs{StrPutLeft} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and prepends the
result to \meta{str var}.  The current contents of the \meta{str
var} are not automatically converted to a string. For example
\begin{demohigh}
\StrSet\lTmpkStr{Functional}
\StrPutLeft\lTmpkStr{Hello}
\StrUse\lTmpkStr
\end{demohigh}
\end{function}

\begin{function}{\StrPutRight}
\begin{syntax}
\cs{StrPutRight} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and appends the
result to \meta{str var}.  The current contents of the \meta{str
var} are not automatically converted to a string. For example
\begin{demohigh}
\StrSet\lTmpkStr{Functional}
\StrPutRight\lTmpkStr{World}
\StrUse\lTmpkStr
\end{demohigh}
\end{function}

\begin{function}{\StrIfVarEmpty,\StrIfVarEmptyTF}
\begin{syntax}
\cs{StrIfVarEmpty} \meta{str var}
\cs{StrIfVarEmptyTF} \meta{str var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{string variable} is entirely empty
(\emph{i.e.} contains no characters at all). For example
\begin{demohigh}
\StrSet\lTmpaStr{abc}
\StrIfVarEmptyTF\lTmpaStr{\Result{Empty}}{\Result{NonEmpty}}
\StrClear\lTmpaStr
\StrIfVarEmptyTF\lTmpaStr{\Result{Empty}}{\Result{NonEmpty}}
\end{demohigh}
\end{function}

\begin{function}{\StrIfEq,\StrIfEqTF}
\begin{syntax}
\cs{StrIfEq} \Arg{tl_1} \Arg{tl_2}
\cs{StrIfEqTF} \Arg{tl_1} \Arg{tl_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the two \meta{token lists} on a character by character
basis (namely after converting them to strings),
and is \texttt{true} if the two \meta{strings} contain the same
characters in the same order.
%Thus for example
%\begin{codehigh}
%\StrIfEq{abc}{\TlToStr{abc}}
%\end{codehigh}
%is logically \texttt{true}.
See \cs{TlIfEq} to compare
tokens (including their category codes) rather than characters.
For example
\begin{demohigh}
\StrIfEqTF{abc}{abc}{\Result{Yes}}{\Result{No}}
\StrIfEqTF{abc}{xyz}{\Result{Yes}}{\Result{No}}
\end{demohigh}
%\begin{demohigh}
%\StrSet\lTmpaStr{abc}
%\StrSet\lTmpbStr{abc}
%\StrSet\lTmpcStr{xyz}
%\StrIfEqTF{\lTmpaStr}{\lTmpbStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\lTmpaStr}{\lTmpcStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\StrUse\lTmpaStr}{\StrUse\lTmpbStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\StrUse\lTmpaStr}{\StrUse\lTmpcStr}{\Result{Yes}}{\Result{No}}
%\end{demohigh}
\end{function}

\begin{function}{\StrIfVarEq,\StrIfVarEqTF}
\begin{syntax}
\cs{StrIfVarEq} \meta{str var_1} \meta{str var_2}
\cs{StrIfVarEqTF} \meta{str var_1} \meta{str var_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the content of two \meta{str variables} and
is logically \texttt{true} if the two contain the same characters
in the same order.  See \cs{TlIfVarEq} to compare tokens
(including their category codes) rather than characters.
\begin{demohigh}
\StrSet\lTmpaStr{abc}
\StrSet\lTmpbStr{abc}
\StrSet\lTmpcStr{xyz}
\StrIfVarEqTF\lTmpaStr\lTmpbStr{\Result{Yes}}{\Result{No}}
\StrIfVarEqTF\lTmpaStr\lTmpcStr{\Result{Yes}}{\Result{No}}
\end{demohigh}
\end{function}

\chapter{Integers (\texttt{Int})}

\section{Scratch Variables of Integers}

\begin{variable}{\lTmpaInt,\lTmpbInt,\lTmpcInt,\lTmpiInt,\lTmpjInt,\lTmpkInt}
Scratch integer for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaInt,\gTmpbInt,\gTmpcInt,\gTmpiInt,\gTmpjInt,\gTmpkInt}
Scratch integer for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Integers}

\begin{function}{\IntEval}
\begin{syntax}
\cs{IntEval} \Arg{integer expression}
\end{syntax}
Evaluates the \meta{integer expression} and returns the result:
for positive results an
explicit sequence of decimal digits not starting with~\texttt{0},
for negative results \texttt{-}~followed by such a sequence, and
\texttt{0}~for zero. For example
\begin{demohigh}
\IntEval{(1+4)*(2-3)/5}
\end{demohigh}
\end{function}

\begin{function}{\IntMathAdd}
\begin{syntax}
\cs{IntMathAdd} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Adds \Arg{integer expression_1} and \Arg{integer expression_2},
and returns the result. For example
\begin{demohigh}
\IntMathAdd{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntMathSub}
\begin{syntax}
\cs{IntMathSub} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Subtracts \Arg{integer expression_2} from \Arg{integer expression_1},
and returns the result. For example
\begin{demohigh}
\IntMathSub{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntMathMult}
\begin{syntax}
\cs{IntMathMult} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Multiplies \Arg{integer expression_1} by \Arg{integer expression_2},
and returns the result. For example
\begin{demohigh}
\IntMathMult{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntMathDiv}
\begin{syntax}
\cs{IntMathDiv} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Divides \Arg{integer expression_1} by \Arg{integer expression_2},
and returns the result. For example
\begin{demohigh}
\IntMathDiv{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntNew}
\begin{syntax}
\cs{IntNew} \meta{integer}
\end{syntax}
Creates a new \meta{integer} or raises an error if the name is
already taken. The declaration is global. The \meta{integer} is
initially equal to $0$.
\end{function}

\begin{function}{\IntUse}
\begin{syntax}
\cs{IntUse} \meta{integer}
\end{syntax}
Recovers the content of an \meta{integer} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
\end{function}

\begin{function}{\IntSet}
\begin{syntax}
\cs{IntSet} \meta{integer} \Arg{integer expression}
\end{syntax}
Sets \meta{integer} to the value of \meta{integer expression},
which must evaluate to an integer (as described for \cs{IntEval}).
For example
\begin{demohigh}
\IntSet\lTmpaInt{3+5}
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntZero}
\begin{syntax}
\cs{IntZero} \meta{integer}
\end{syntax}
Sets \meta{integer} to $0$. For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntZero\lTmpaInt
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntIncr}
\begin{syntax}
\cs{IntIncr} \meta{integer}
\end{syntax}
Increases the value stored in \meta{integer} by $1$.
For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntIncr\lTmpaInt
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntDecr}
\begin{syntax}
\cs{IntDecr} \meta{integer}
\end{syntax}
Decreases the value stored in \meta{integer} by $1$.
For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntDecr\lTmpaInt
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntAdd}
\begin{syntax}
\cs{IntAdd} \meta{integer} \Arg{integer expression}
\end{syntax}
Adds the result of the \meta{integer expression} to the current
content of the \meta{integer}. For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntAdd\lTmpaInt{2}
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntSub}
\begin{syntax}
\cs{IntSub} \meta{integer} \Arg{integer expression}
\end{syntax}
Subtracts the result of the \meta{integer expression} from the
current content of the \meta{integer}. For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntSub\lTmpaInt{3}
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntStepVariable}
\begin{syntax}
\cs{IntStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl~var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be integer expressions.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is evaluated,
with the \meta{tl~var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl~var}.
For example
\begin{demohigh}
\IgnoreSpacesOn
\TlClear\lTmpaTl
\IntStepVariable{1}{3}{30}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{~}
}
\Result{\Value\lTmpaTl}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\IntCompare,\IntCompareTF}
\begin{syntax}
\cs{IntCompare} \Arg{intexpr_1} \meta{relation} \Arg{intexpr_2}
\cs{IntCompareTF} \Arg{intexpr_1} \meta{relation} \Arg{intexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
This function first evaluates each of the \meta{integer expressions}
as described for \cs{IntEval}. The two results are then
compared using the \meta{relation}:\par
{\centering\begin{tabular}{ll}
Equal        & \texttt{=} \\
Greater than & \texttt{>} \\
Less than    & \texttt{<} \\
\end{tabular}\par}
For example
\begin{demohigh}
\IntCompareTF{2}>{1}{\Result{Greater}}{\Result{Less}}
\IntCompareTF{2}>{3}{\Result{Greater}}{\Result{Less}}
\end{demohigh}
\end{function}

\chapter{Floating Point Numbers (\texttt{Fp})}

\section{Scratch Variables of Floating Point Numbers}

\begin{variable}{\lTmpaFp,\lTmpbFp,\lTmpcFp,\lTmpiFp,\lTmpjFp,\lTmpkFp}
Scratch floating point numbers for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaFp,\gTmpbFp,\gTmpcFp,\gTmpiFp,\gTmpjFp,\gTmpkFp}
Scratch floating point numbers for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Floating Point Numbers}

\begin{function}{\FpEval}
\begin{syntax}
\cs{FpEval} \Arg{floating point expression}
\end{syntax}
Evaluates the \meta{floating point expression} and returns the
result as a decimal number with no
exponent.  Leading or trailing zeros may be inserted to compensate
for the exponent.  Non-significant trailing zeros are trimmed, and
integers are expressed without a decimal separator.  The values
$\pm\infty$ and \nan{} trigger an \enquote{invalid operation}
exception.
For a tuple, each item is converted using \cs{FpEval} and they are combined as
\verb|(|\meta{fp_1}\verb*|, |\meta{fp_2}\verb*|, |\ldots{}\meta{fp_n}\verb|)|
if $n>1$ and \verb|(|\meta{fp_1}\verb|,)| or \verb|()| for fewer items.
%This function is identical to \cs{fp_to_decimal:n}.
For example
\begin{demohigh}
\FpEval{(1.2+3.4)*(5.6-7.8)/9}
\end{demohigh}
\end{function}

\begin{function}{\FpMathAdd}
\begin{syntax}
\cs{FpMathAdd} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Adds \Arg{fpexpr_1} and \Arg{fpexpr_2},
and returns the result. For example
\begin{demohigh}
\FpMathAdd{2.8}{3.7}
\FpMathAdd{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathSub}
\begin{syntax}
\cs{FpMathSub} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Subtracts \Arg{fpexpr_2} from \Arg{fpexpr_1},
and returns the result. For example
\begin{demohigh}
\FpMathSub{2.8}{3.7}
\FpMathSub{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathMult}
\begin{syntax}
\cs{FpMathMult} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Multiplies \Arg{fpexpr_1} by \Arg{fpexpr_2},
and returns the result. For example
\begin{demohigh}
\FpMathMult{2.8}{3.7}
\FpMathMult{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathDiv}
\begin{syntax}
\cs{FpMathDiv} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Divides \Arg{fpexpr_1} by \Arg{fpexpr_2},
and returns the result. For example
\begin{demohigh}
\FpMathDiv{2.8}{3.7}
\FpMathDiv{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathSign}
\begin{syntax}
\cs{FpMathSign} \Arg{fpexpr}
\end{syntax}
Evaluates the \meta{fpexpr} and returns the value
using \cs{FpEval}\verb|{sign(|\meta{result}\verb|)}|: $+1$ for positive
numbers and for $+\infty$, $-1$ for negative numbers and for
$-\infty$, $\pm 0$ for $\pm 0$.  If the operand is a tuple or is
\nan{}, then \enquote{invalid operation} occurs and the result
is $0$. For example
\begin{demohigh}
\FpMathSign{3.5}
\FpMathSign{-2.7}
\end{demohigh}
\end{function}

\begin{function}{\FpNew}
\begin{syntax}
\cs{FpNew} \meta{fp var}
\end{syntax}
Creates a new \meta{fp var} or raises an error if the name is
already taken. The declaration is global. The \meta{fp~var} is
initially $+0$.
\end{function}

\begin{function}{\FpLogVar}
\begin{syntax}
\cs{FpLogVar} \meta{fp var}
\end{syntax}
Writes the value of \meta{fp var} in the log file.
\end{function}

\begin{function}{\FpShowVar}
\begin{syntax}
\cs{FpShowVar} \meta{fp var}
\end{syntax}
Displays the value of \meta{fp var} in the terminal.
\end{function}

\begin{function}{\FpUse}
\begin{syntax}
\cs{FpUse} \meta{fp var}
\end{syntax}
Recovers the value of the \meta{fp var} and returns the value as a
decimal number with no exponent.
%Leading or trailing zeros may be inserted to compensate for the
%exponent.  Non-significant trailing zeros are trimmed.  Integers are
%expressed without a decimal separator.  The values $\pm\infty$
%and \nan{} trigger an \enquote{invalid operation} exception.
%For a tuple, each item is converted using \cs{fp_to_decimal:n} and they are combined as
%|(|\meta{fp_1}\verb*|, |\meta{fp_2}\verb*|, |\ldots{}\meta{fp_n}|)|
%if $n>1$ and |(|\meta{fp_1}|,)| or |()| for fewer items.
%This function is identical to \cs{fp_to_decimal:N}.
\end{function}

\begin{function}{\FpConst}
\begin{syntax}
\cs{FpConst} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Creates a new constant \meta{fp var} or raises an error if the name
is already taken. The \meta{fp var} is set globally equal to
the result of evaluating the \meta{floating point expression}.
For example
\begin{demohigh}
\FpConst\cMyPiFp{3.1415926}
\FpUse\cMyPiFp
\end{demohigh}
\end{function}

\begin{function}{\FpSet}
\begin{syntax}
\cs{FpSet} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Sets \meta{fp var} equal to the result of computing the
\meta{floating point expression}. For example
\begin{demohigh}
\FpSet\lTmpaFp{4/7}
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpZero}
\begin{syntax}
\cs{FpZero} \meta{fp var}
\end{syntax}
Sets the \meta{fp var} to $+0$. For example
\begin{demohigh}
\FpSet\lTmpaFp{5.3}
\FpZero\lTmpaFp
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpAdd}
\begin{syntax}
\cs{FpAdd} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Adds the result of computing the \meta{floating point expression} to
the \meta{fp var}.
This also applies if \meta{fp var} and \meta{floating point
expression} evaluate to tuples of the same size. For example
\begin{demohigh}
\FpSet\lTmpaFp{5.3}
\FpAdd\lTmpaFp{2.11}
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpSub}
\begin{syntax}
\cs{FpSub} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Subtracts the result of computing the \meta{floating point
expression} from the \meta{fp var}.
This also applies if \meta{fp var} and \meta{floating point
expression} evaluate to tuples of the same size. For example
\begin{demohigh}
\FpSet\lTmpaFp{5.3}
\FpSub\lTmpaFp{2.11}
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpStepVariable}
\begin{syntax}
\cs{FpStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be floating point
expressions evaluating to a floating point number, not a tuple.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is inserted into the input stream,
with the \meta{tl var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl var}.
For example
\begin{demohigh}
\IgnoreSpacesOn
\TlClear\lTmpaTl
\FpStepVariable{1}{0.1}{1.5}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{~}
}
\Result{\Value\lTmpaTl}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\FpIfExist,\FpIfExistTF}
\begin{syntax}
\cs{FpIfExist} \meta{fp var}
\cs{FpIfExistTF} \meta{fp var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{fp var} is currently defined.  This does not
check that the \meta{fp var} really is a floating point variable.
For example
\begin{demohigh}
\FpIfExistTF\lTmpaFp{\Result{Yes}}{\Result{No}}
\FpIfExistTF\lMyUndefinedFp{\Result{Yes}}{\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\FpCompare,\FpCompareTF}
\begin{syntax}
\cs{FpCompare} \Arg{fpexpr_1} \meta{relation} \Arg{fpexpr_2}
\cs{FpCompareTF} \Arg{fpexpr_1} \meta{relation} \Arg{fpexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the \meta{fpexpr_1} and the \meta{fpexpr_2}, and returns
\texttt{true} if the \meta{relation} is obeyed. For example
\begin{demohigh}
\FpCompareTF{1}>{0.9999}{\Result{Greater}}{\Result{Less}}
\FpCompareTF{1}>{1.0001}{\Result{Greater}}{\Result{Less}}
\end{demohigh}
Two floating points
$x$ and $y$ may obey four mutually exclusive relations:
$x<y$, $x=y$, $x>y$, or $x?y$ (\enquote{not ordered}).  The last
case occurs exactly if one or both operands is \nan{} or is a tuple,
unless they are equal tuples.  Note that a \nan{} is distinct from
any value, even another \nan{}, hence $x=x$ is not true for
a \nan{}.  To test if a value is \nan{}, compare it to an arbitrary
number with the \enquote{not ordered} relation.\par
%\begin{demohigh}
%\FpCompareTF{0/0}?{0}{\Result{Is~a~Nan}}{\Result{Isn't~a~NaN}}
%\end{demohigh}
Tuples are equal if they have the same number of items and items
compare equal (in particular there must be no \nan{}).
At present any other comparison with tuples yields \verb|?| (not ordered).
This is experimental.
\end{function}

\chapter{Dimensions (\texttt{Dim})}

\section{Scratch and Constant Dimensions}

\begin{variable}{\lTmpaDim,\lTmpbDim,\lTmpcDim,\lTmpiDim,\lTmpjDim,\lTmpkDim}
Scratch dimensions for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaDim,\gTmpbDim,\gTmpcDim,\gTmpiDim,\gTmpjDim,\gTmpkDim}
Scratch dimensions for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\cMaxDim}
The maximum value that can be stored as a dimension.  This can also
be used as a component of a skip.
\end{variable}

\begin{variable}{\cZeroDim}
A zero length as a dimension.  This can also be used as a component
of a skip.
\end{variable}

\section{Public Functions for Dimensions}

\begin{function}{\DimEval}
\begin{syntax}
\cs{DimEval} \Arg{dimension expression}
\end{syntax}
Evaluates the \meta{dimension expression}, expanding any
dimensions and token list variables within the \meta{expression}
to their content (without requiring \cs{DimUse}/\cs{TlUse})
and applying the standard mathematical rules. The result of the
calculation is returned as a \meta{dimension denotation}.
%This is expressed in points (\texttt{pt}), and requires suitable
%termination if used in a \TeX{}-style assignment as it is \emph{not}
%an \meta{internal dimension}.
For example
\begin{demohigh}
\DimEval{(1.2pt+3.4pt)/9}
\end{demohigh}
%\DimEval{(1.2pt+3.4pt)*(5.6-7.8)/9}
\end{function}

\begin{function}{\DimMathAdd}
\begin{syntax}
\cs{DimMathAdd} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Adds \Arg{dimexpr_1} and \Arg{dimexpr_2},
and returns the result. For example
\begin{demohigh}
\DimMathAdd{2.8pt}{3.7pt}
\DimMathAdd{3.8pt-1pt}{2.7pt+1pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathSub}
\begin{syntax}
\cs{DimMathSub} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Subtracts \Arg{dimexpr_2} from \Arg{dimexpr_1},
and returns the result. For example
\begin{demohigh}
\DimMathSub{2.8pt}{3.7pt}
\DimMathSub{3.8pt-1pt}{2.7pt+1pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathRatio}
\begin{syntax}
\cs{DimMathRatio} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Parses the two \meta{dimension expressions},
then calculates the ratio of the two and returns it.
The result is a ratio expression
between two integers, with all distances converted to scaled points.
For example
\begin{demohigh}
\DimMathRatio{5pt}{10pt}
\end{demohigh}
The returned value is suitable for use inside a \meta{dimension expression}
such as
\begin{codehigh}
\DimSet\lTmpaDim{10pt*\DimMathRatio{5pt}{10pt}}
\end{codehigh}
\end{function}

\begin{function}{\DimMathSign}
\begin{syntax}
\cs{DimMathSign} \Arg{dimexpr}
\end{syntax}
Evaluates the \meta{dimexpr} then returns $1$ or $0$ or $-1$
according to the sign of the result. For example
\begin{demohigh}
\DimMathSign{3.5pt}
\DimMathSign{-2.7pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathAbs}
\begin{syntax}
\cs{DimMathAbs} \Arg{dimexpr}
\end{syntax}
Converts the \meta{dimexpr} to its absolute value,
returning the result as a \meta{dimension denotation}.
For example
\begin{demohigh}
\DimMathAbs{3.5pt}
\DimMathAbs{-2.7pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathMax,\DimMathMin}
\begin{syntax}
\cs{DimMathMax} \Arg{dimexpr_1} \Arg{dimexpr_2}
\cs{DimMathMin} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Evaluates the two \meta{dimension expressions} and returns either the
maximum or minimum value as appropriate as a \meta{dimension denotation}.
For example
\begin{demohigh}
\DimMathMax{3.5pt}{-2.7pt}
\DimMathMin{3.5pt}{-2.7pt}
\end{demohigh}
\end{function}

\begin{function}{\DimNew}
\begin{syntax}
\cs{DimNew} \meta{dimension}
\end{syntax}
Creates a new \meta{dimension} or raises an error if the name is
already taken. The declaration is global. The \meta{dimension}
is initially equal to $0$\,pt.
\end{function}

\begin{function}{\DimLog}
\begin{syntax}
\cs{DimLog} \Arg{dimension expression}
\end{syntax}
Writes the result of evaluating the \meta{dimension expression}
in the log file. For example
\begin{codehigh}
\DimLog{\lFooSomeDim+1cm}
\end{codehigh}
\end{function}

\begin{function}{\DimLogVar}
\begin{syntax}
\cs{DimLogVar} \meta{dimension}
\end{syntax}
Writes the value of the \meta{dimension} in the log file. For example
\begin{codehigh}
\DimLogVar\lFooSomeDim
\end{codehigh}
\end{function}

\begin{function}{\DimShow}
\begin{syntax}
\cs{DimShow} \Arg{dimension expression}
\end{syntax}
Displays the result of evaluating the \meta{dimension expression}
on the terminal. For example
\begin{codehigh}
\DimShow{\lFooSomeDim+1cm}
\end{codehigh}
\end{function}

\begin{function}{\DimShowVar}
\begin{syntax}
\cs{DimShowVar} \meta{dimension}
\end{syntax}
Displays the value of the \meta{dimension} on the terminal. For example
\begin{codehigh}
\DimShowVar\lFooSomeDim
\end{codehigh}
\end{function}

\begin{function}{\DimUse}
\begin{syntax}
\cs{DimUse} \meta{dimension}
\end{syntax}
Recovers the content of a \meta{dimension} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
\end{function}

\begin{function}{\DimConst}
\begin{syntax}
\cs{DimConst} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Creates a new constant \meta{dimension} or raises an error if the
name is already taken. The value of the \meta{dimension} is set
globally to the \meta{dimension expression}. For example
\begin{demohigh}
\DimConst\cFooSomeDim{1cm}
\DimUse\cFooSomeDim
\end{demohigh}
\end{function}

\begin{function}{\DimSet}
\begin{syntax}
\cs{DimSet} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Sets \meta{dimension} to the value of \meta{dimension expression}, which
must evaluate to a length with units.
\end{function}

\begin{function}{\DimSetEq}
\begin{syntax}
\cs{DimSetEq} \meta{dimension_1} \meta{dimension_2}
\end{syntax}
Sets the content of \meta{dimension_1} equal to that of
\meta{dimension_2}. For example
\begin{demohigh}
\DimSet\lTmpaDim{10pt}
\DimSetEq\lTmpbDim\lTmpaDim
\DimUse\lTmpbDim
\end{demohigh}
\end{function}

\begin{function}{\DimZero}
\begin{syntax}
\cs{DimZero} \meta{dimension}
\end{syntax}
Sets \meta{dimension} to $0$\,pt. For example
\begin{demohigh}
\DimSet\lTmpaDim{1em}
\DimZero\lTmpaDim
\DimUse\lTmpaDim
\end{demohigh}
\end{function}

\begin{function}{\DimZeroNew}
\begin{syntax}
\cs{DimZeroNew} \meta{dimension}
\end{syntax}
Ensures that the \meta{dimension} exists globally by applying
\cs{DimNew} if necessary, then applies
\cs{DimZero} to set the \meta{dimension} to zero. For example
\begin{demohigh}
\DimZeroNew\lFooSomeDim
\DimUse\lFooSomeDim
\end{demohigh}
\end{function}

\begin{function}{\DimAdd}
\begin{syntax}
\cs{DimAdd} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Adds the result of the \meta{dimension expression} to the current
content of the \meta{dimension}. For example
\begin{demohigh}
\DimSet\lTmpaDim{5.3pt}
\DimAdd\lTmpaDim{2.11pt}
\DimUse\lTmpaDim
\end{demohigh}
\end{function}

\begin{function}{\DimSub}
\begin{syntax}
\cs{DimSub} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Subtracts the result of the \meta{dimension expression} from the
current content of the \meta{dimension}. For example
\begin{demohigh}
\DimSet\lTmpaDim{5.3pt}
\DimSub\lTmpaDim{2.11pt}
\DimUse\lTmpaDim
\end{demohigh}
\end{function}

\begin{function}{\DimStepVariable}
\begin{syntax}
\cs{DimStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be dimension expressions.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is inserted into the input stream,
with the \meta{tl var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl var}.
For example
\begin{demohigh}
\IgnoreSpacesOn
\TlClear\lTmpaTl
\DimStepVariable{1pt}{0.1pt}{1.5pt}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{~}
}
\Result{\Value\lTmpaTl}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\DimIfExist,\DimIfExistTF}
\begin{syntax}
\cs{DimIfExist} \meta{dimension}
\cs{DimIfExistTF} \meta{dimension} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{dimension} is currently defined.  This does
not check that the \meta{dimension} really is a dimension variable.
For example
\begin{demohigh}
\DimIfExistTF\lTmpaDim{\Result{Yes}}{\Result{No}}
\DimIfExistTF\lFooUndefinedDim{\Result{Yes}}{\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\DimCompare,\DimCompareTF}
\begin{syntax}
\cs{DimCompare} \Arg{dimexpr_1} \meta{relation} \Arg{dimexpr_2}
\cs{DimCompareTF} \Arg{dimexpr_1} \meta{relation} \Arg{dimexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
This function first evaluates each of the \meta{dimension expressions}
as described for \cs{DimEval}. The two results are then
compared using the \meta{relation}:\par
{\centering
\begin{tabular}{ll}
Equal        & \verb|=| \\
Greater than & \verb|>| \\
Less than    & \verb|<| \\
\end{tabular}\par}
For example
\begin{demohigh}
\DimCompareTF{1pt}>{0.9999pt}{\Result{Greater}}{\Result{Less}}
\DimCompareTF{1pt}>{1.0001pt}{\Result{Greater}}{\Result{Less}}
\end{demohigh}
\end{function}

\begin{function}{\DimCase}
\begin{syntax}
\cs{DimCase} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded.
\end{function}

\begin{function}{\DimCaseT}
\begin{syntax}
\cs{DimCaseT} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{true code}
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case).
\end{function}

\begin{function}{\DimCaseF}
\begin{syntax}
\cs{DimCaseF} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{false code}
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded. If none of the cases
match then the \meta{false code} is inserted.
For example
\begin{demohigh}
\IgnoreSpacesOn
\DimSet\lTmpaDim{5pt}
\DimCaseF{2\lTmpaDim}{
  {5pt}     {Small}
  {4pt+6pt} {Medium}
  {-10pt}   {Negative}
}{
  No Match!
}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\DimCaseTF}
\begin{syntax}
\cs{DimCaseTF} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{true code}
~ ~ \Arg{false code}
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case), while if none
match then the \meta{false code} is inserted.
%For example
%\begin{demohigh}
%\IgnoreSpacesOn
%\DimSet\lTmpaDim{5pt}
%\DimCaseTF{2\lTmpaDim}{
%  {5pt}     {Small}
%  {4pt+6pt} {Medium}
%  {-10pt}   {Negative}
%}{
%  [Some Match!]
%}{
%  [No Match!]
%}
%\IgnoreSpacesOff
%\end{demohigh}
\end{function}

\chapter{The Source Code}

%\CodeHigh{lite}
\setlength\parskip{0pt}
\dochighinput[language=latex/latex3]{functional.sty}

\end{document}
